{"version":3,"sources":["webpack:///webpack/bootstrap 2109037cf7f584f5823f","webpack:///./src/index.js","webpack:///./src/standard-period-selector.js"],"names":[],"mappings":"YACA,cAMA,MACA,eAGA,mBACA,CACA,cACA,EAIA,kDAGA,KAGA,YACA,OAIA,IAzBA,iBA4BA,MAGA,MAGA,0BCtCA,CACA,uBAEA,GAAC,cACD,uBACA,oBACA,yBACA,OACA,yBAEA,6CACA,KAEA,6BAEA,KAAC,qDACD,SACA,oFACA,gEAA2F,aAC3F,IACA,GAAC,eCpBD,CAKA,iCACA,CAqlCA,YApjCA,cAIA,OACA,aACA,4CACA,yCACA,6CACA,uCACA,kBACA,IACA,oCAEA,sBACA,oBACA,IACA,+BACA,6CACA,yBACA,kBACA,kBACA,IACA,iBACA,aACA,uBACA,CACA,iBAGA,oBA8CA,kmBACA,iBACA,YACA,eACA,eACA,IAGA,oCAEA,+BACA,uBACA,uBAEA,KACA,aACA,kBACA,sCACA,GACA,mBACA,qBAAa,IAGb,yBACA,MAEA,sBACA,CAGA,kBACA,IAGA,KAFA,cACA,sBAEA,YAEA,MAEA,kCACA,IAEA,GAMA,EAKA,EACA,IAbA,OAEA,IACA,IACA,IACA,wBACA,sBAEA,yBACA,kBACA,cACA,EAGA,SACA,kBAEA,kBACA,kCACO,aACP,8BAGA,qBACA,2BAA0C,UAAQ,EAClD,cACA,gBACA,yBAEA,OAEA,UACA,yBACA,MACA,eACA,EAGA,kCACA,MACA,eACA,EAGA,wCAA+D,SAAQ,EACvE,kCACA,yBACA,yBACA,6BACA,sBAOA,gBAAwD,SAAQ,EAChE,+BAAyE,SAAQ,EACjF,uBACA,QACA,8BAGA,mCACA,uBACA,WACA,uDAEA,sDAEA,KAIA,uBAEA,IAGA,KAFA,SACA,mBAEA,uBASA,mCACA,QACA,+BACA,eAcA,IAGA,sBACA,IAEA,GACA,EAUA,IAZA,SAGA,oBACA,cACA,iBACA,eACA,sBACA,yBACA,uBACA,iBAGA,qBACA,aACA,mBAEO,yBACP,qBACA,aACA,oBACA,uBACA,mBAEO,yBACP,qBACA,cACA,oBACA,mBAGA,oCACA,cACA,wBACS,UACT,SACA,OACA,SACA,oBACA,yBACA,oBACA,aAGA,UACA,UACA,OACA,WACA,uBACA,oBAIA,cACA,YAEA,KAEA,GACA,iBACA,oCAEA,uBAMA,wBACA,iBAA0C,SAAQ,MAClD,4BACA,oBACA,YACA,KACA,eACA,aAEA,QACA,mBACS,GACT,2CACS,IACT,4CACA,2CAEA,2CACA,yDACA,2CAEA,IACA,OACA,EAEA,2BACA,IAGA,KAFA,cACA,kBAEA,oBACA,kBACA,sCACA,MAEA,oCAA+C,EAAQ,KACvD,kDAAgE,EAAQ,SACxE,qEACA,0DACA,wDACA,gBACA,WACA,UACA,eAIA,aACA,oBACA,eACA,uBACA,+DACA,IACA,oBACA,wEACA,uCACA,cAEA,2DAGA,qDACA,IACA,oBACA,yCACA,6EACA,GAEA,2DAGA,CACA,WAGA,QACA,MACA,SACA,UACA,SACA,UACA,SACA,OAQA,YACA,iBACA,SAGA,6BAEA,EAEA,qBACA,gBAGA,qBAEA,OACA,SACA,2BACA,IACA,gCACA,iCACA,IACA,EACA,SACA,6BACA,MACA,sBAEA,wBAAiC,SAAQ,EACzC,kBACA,GACA,8BACA,aACA,cACA,gBACA,gBACS,IACT,6BACA,cACA,gBACA,gBACS,IACT,8CACA,aACA,cACA,gBACA,gBACS,IACT,2CACA,qBACA,gBACA,gBACS,IACT,4BACA,gBACA,gBACA,GACS,WACT,6BACA,gBACA,gBACA,QACA,OAIA,oBACA,EAEA,+BACA,yBACA,mBAGA,UACA,yBAAwC,SAAQ,EAChD,wCACA,mCACA,yBAGA,aAEA,2BACA,IAGA,GACA,IAHA,cACA,gBAGA,EACA,OACA,iEAAgE,SAAQ,EACxE,qFACA,yDAGA,+CACA,oBACA,4CACA,mDACA,qBAEA,mBACA,uDACA,eACA,yBACA,oBACA,qEACA,yEACA,WACA,QAGA,iDACA,oCACA,oBACA,UACA,SACA,UACA,SACA,MAGA,UACA,iBACA,SAIA,QAEA,mEAEA,uBACA,gBAEA,iBACA,IACA,GACA,kBACA,cACA,OACA,GAEA,cADA,8CAGA,OACA,6CAGA,aAEA,qBACA,IACA,GACA,EACA,EACA,EACA,EACA,EACA,iBACA,uBACA,yBACA,KAEA,gBACA,cACA,OACA,SAEA,OACA,cACA,eAEA,gDAEA,aACA,YAEA,6CAEA,gBACA,iCACA,mFACA,OACA,OACA,uEAGA,4CACA,mCAEA,uBACA,EACA,CAEA,kBACA,IACA,GACA,EACA,EACA,iBACA,QACA,OACA,kBACA,cACA,mBACA,qCAGA,mBACA,OACA,OACA,SACA,oCAGA,mEACA,uBAEA,GAGA,gBACA,IAEA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,IARA,OASA,kBACA,cACA,mBACA,qCAIA,qCACA,eACA,MACA,uBAIA,mCAGA,2CAEA,qCACA,SACA,cACA,QACA,cAIA,aACA,MACA,aACA,oCACA,oBACA,SAGA,WAGA,kCAOA,eACA,MACA,uBAEA,gBACA,MACA,uBAIA,MACA,MACA,MACA,eACA,QACA,UACA,QAGA,WAIA,qBAGA,uBAAyC,aAEzC,aACA,cACA,uBACA,QACA,yBACA,oBACA,yCACA,gDACA,cACA,QAEA,KACA,KACA,MACA,aACA,QACA,UACA,WACA,aACA,OAGA,WACA,iBACA,SAKA,QACA,OACA,MACA,aACA,QACA,UAOA,SAIA,IACA,eACA,oBAIA,cAAqB,EAAO,IAC5B,MACA,kCAIA,+BACA,kBACA,kBACA,aACA,qBACA,gBACA,EACA,CAEA,gBACA,OACA,SACA,+CAEA,0DAEA,sCAEA,0DAEA,EAIA,QACA,OACA,cACA,CACA,WACA,QACA,eACA,gBACA,gBACA,sBACA,uBACA,aACA,UACA,gBACA,iBACA,SACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,IACA,YACA,UACA,kBACA,iBACA,kBACA,wBACA,yBACA,eACA,gBACA,kBACA,mBACA,CAGA,cACA,CACA,6BACA,MACA,gBACA,uBACA,oCACA,qBACA,eACA,mBACA,mBACA,aAUA,6IACA,QACA,UACA,YACA,qCACA,OACA,MACA,yBACA,aACA,oBACA,sBAKA,aACA,CAQA,0IACA,OACA,WACA,iDACA,OACA,QACA,eAMA,qBACA,QACA,aACA,sCACA,CASA,wIACA,2DACA,4EACA,yEACA,wEAEA,4DAEA,qDACA,4EACA,6BACA,4CAEA,mFAEA,6CACA,+CACA,sDACA,iDACA,8CACA,wCAEA,oBACA,iBACA,UACA,8BAEA,uCACA,0EACA,8FACA,CACA,+DACA,wDAEA,6BACA,GACA,CAEA,gDACA,IACA,GAGA,EACA,IAHA,IACA,IAIA,0BAA4C,SAAQ,EACpD,sCACA,sBACA,QACA,6BACA,6BAEA,mBACA,QACA,OACA,SAEA,EAEA,kBACA,aACA,WAEA,gBACA,OACA,eACA,8BACA,gBACA,OACA,8BACA,iBACA,OACA,KACA,iBACA,OACA,EACA,qBACA,OACA,EACA,oBACA,6BACA,QACA,eACA,iBACA,kCACA,YACA,YACA,iBACA,mCACA,KACA,aACA,iBACA,gCACA,MACA,wBACA,YACA,wCACA,2DACA,YAKA,WAEA,mCACA,YACA,uBACA,MACA,UACA,WAEA,mBAEA,EACA,IAGA,gBACA,IAIA,GACA,EACA,EAIA,EAIA,EAEA,IAfA,SACA,gBACA,kBAIA,uBACA,kBACA,kCAEA,UACA,kBACA,2DAIA,gDAEA,qBACA,iCAMA,oBACA,kBACA,qEACA,IACA,gCACA,yBACS,gBACT,yBAEA,uBACA,MACA,uBACA,wBACA,EAIA,eACA,cACA,SAEA,qBACA,mBACA,uBACA,wBACA,gCACA,OACA,aAAyC,SAAQ,EACjD,QACA,cACA,KAEA,gBACA,wBACA,GACA,UAEA,OAGA,yBAEA,qBACA,CAEA","file":"standard-period-selector.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2109037cf7f584f5823f","'use strict';\nconst StandardPeriodSelector = require('./standard-period-selector');\n\n;(function (env, factory) {\n  if (typeof module === 'object' && module.exports) {\n    module.exports = env.document\n       ? factory(env) : function (win) {\n         if (!win.document) {\n           throw new Error('Window with document not present');\n         }\n         return factory(win, true);\n       };\n  } else {\n    env.StandardPeriodSelector = factory(env, true);\n  }\n})(typeof window !== 'undefined' ? window : this, function (_window, windowExists) {\n  var FC = _window.FusionCharts;\n  FC.register('extension', ['private', 'standard-period-selector', function () {\n    FC.registerComponent('extensions', 'standard-period-selector', StandardPeriodSelector({FusionCharts: FC}));\n  }]);\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 0\n// module chunks = 0","'use strict';\n/**\n * Class definition of StandardPeriodSelector\n */\n\nmodule.exports = function (dep) {\n  class StandardPeriodSelector {\n    /**\n     *In time series charts, it is required to have some\n     *optional UI buttons / options to select the visible\n     *canvas range to a standard time period like\n     *1 month, 1 year, 5 years, 3 months,  YTD etc.\n     *Also, from the same UI it should have an option\n     *to select the full date-time range.\n     *\n     *The configuration object for the extension is as follows:\n     *The extension provides an optional tool (UI buttons)\n     *for the user to select various popular standard time periods\n     *like 1 week, 1 month, 3 month, 1 year, 5 year, YTD, QTD,\n     *MTD, DTT, All etc.\n     *\n     *@example\n     *datasource: {\n     *  extension: {\n     *     'standard-period-selector': {\n     *       'disabled': 'false',\n     *       'default-select': 'ALL',\n     *       'posWrtCanvas': 'top',\n     *       'anchor-align': 'left',\n     *       'layout': 'inline',\n     *       'alignment': 'left',\n     *       'orientation': 'horizontal',\n     *     }\n     *   }\n     *}\n     *\n     *\n     */\n\n    constructor () {\n      /**\n       * @private\n       */\n      var self = this;\n      self.ratio = 8;\n      self.toolbox = FusionCharts.getComponent('api', 'toolbox');\n      self.HorizontalToolbar = self.toolbox.HorizontalToolbar;\n      self.ComponentGroup = self.toolbox.ComponentGroup;\n      self.SymbolStore = self.toolbox.SymbolStore;\n      self.all = 1;\n      self.calculatedPeriods = [];\n      self.startDataset = 0;\n      // self.endDataset = self.globalReactiveModel.model['x-axis-absolute-range-end'];\n      self.startActiveWindow = 0;\n      self.endActiveWindow = 1;\n      self.standardCalculatedPeriods = [];\n      self.standardContexualPeriods = [];\n      self.startPointUnit = 0;\n      self.startPointMultiplier = 0;\n      self.noCalcButtons = 0;\n      self.minimumBucket = 1;\n      self.buttonGroup = {};\n      self.toolbar = {};\n      self.categoryClicked;\n      self.btns = {\n        contextualObj: {},\n        calculatedObj: {}\n      };\n\n      self.tdButtons = [\n        {\n          'name': 'YTD',\n          'abbreviation': 'YTD',\n          'parent': 'year',\n          'milliseconds': 31104000000,\n          'description': 'Year to Date'\n        },\n        {\n          'name': 'QTD',\n          'abbreviation': 'QTD',\n          'parent': 'month',\n          'multiplier': 3,\n          'milliseconds': 7776000000,\n          'description': 'Quarter to Date'\n        },\n        {\n          'name': 'MTD',\n          'abbreviation': 'MTD',\n          'parent': 'month',\n          'milliseconds': 2592000000,\n          'description': 'Month to Date'\n        },\n        {\n          'name': 'WTD',\n          'abbreviation': 'WTD',\n          'parent': 'day',\n          'multiplier': 7,\n          'milliseconds': 604800000,\n          'description': 'Week to Date'\n        },\n        {\n          'name': 'Y',\n          'abbreviation': 'Y',\n          'parent': 'day',\n          'milliseconds': 86400000,\n          'description': 'Yesterday'\n        },\n        {\n          'name': 'T',\n          'abbreviation': 'T',\n          'parent': 'day',\n          'milliseconds': 86400000,\n          'description': 'Today'\n        }\n      ];\n      self.config = {\n        anchorPositions: 'right',\n        all: '1',\n        contextual: '1',\n        calculated: '1',\n        tertiaryTimePeriods: {}\n      };\n\n      self._babTimer = 0;\n\n      self.propsChangeListener = (start, end) => {\n        self.startActiveWindow = start[1];\n        self.endActiveWindow = end[1];\n\n        if (self._babTimer) {\n          if (!self.updatePending) {\n            self.updatePending = true;\n            setTimeout(function () {\n              self.updatePending = false;\n              self.onActiveRangeChange();\n            }, self._babTimer);\n          }\n        } else {\n          self._babTimer = 200;\n          self.onActiveRangeChange();\n        }\n      };\n    }\n\n    // --test case made--\n    hideAllCalcBtns () {\n      var self = this,\n        calculatedObj = self.btns.calculatedObj,\n        i;\n      for (i in calculatedObj) {\n        calculatedObj[i].btn.hide();\n      }\n    }\n\n    showApplicableCalculatedButtons () {\n      var self = this,\n        targetBlock,\n        i = 0,\n        ii = 0,\n        j = 0,\n        jj = 0,\n        activeWindow = self.endActiveWindow - self.startActiveWindow,\n        key,\n        anchorPositions = self.anchorPositions,\n        calculatedObj = self.btns.calculatedObj,\n        timePeriods = self.timePeriods,\n        interval = 0,\n        name,\n        abbreviation,\n        standardCalculatedPeriods = [],\n        minimumBucket = self.minimumBucket,\n        maximumBucket = self.maximumBucket;\n\n      if (anchorPositions === 'right') {\n        targetBlock = self.endActiveWindow - self.startDataset;\n      } else if (anchorPositions === 'left') {\n        targetBlock = self.endDataset - self.startActiveWindow;\n      }\n\n      self.hideAllCalcBtns();\n      for (i = 0, ii = timePeriods.length; i < ii; i++) {\n        interval = timePeriods[i].interval;\n        name = timePeriods[i].name;\n        abbreviation = timePeriods[i].abbreviation.single;\n        // checking whether the unit is applicable for the current target block\n        if (targetBlock / interval >= 1) {\n          // checking whether the unit is of the higher order and only multiplier 1 is applicable\n          if (Math.floor((activeWindow) / interval) < 1) {\n            standardCalculatedPeriods.push({\n              'name': name,\n              'abbreviation': abbreviation,\n              'multipliers': [1]\n            });\n          } else { // if the unit is of the order of the target block and calculating the multipliers\n            standardCalculatedPeriods.push({\n              'name': name,\n              'abbreviation': abbreviation,\n              'multipliers': []\n            });\n            // calculating and populating the applicable multpliers of each unit\n            for (j = 0, jj = timePeriods[i].multipliers.length; j < jj; j++) {\n              if ((activeWindow / self.ratio < timePeriods[i].multipliers[j] * interval) &&\n                (timePeriods[i].multipliers[j] * interval) > minimumBucket &&\n                (timePeriods[i].multipliers[j] * interval) < maximumBucket) {\n                standardCalculatedPeriods[standardCalculatedPeriods.length - 1].multipliers.push(\n                  timePeriods[i].multipliers[j]);\n              }\n            }\n          }\n        }\n      }\n\n      for (i = 0, ii = standardCalculatedPeriods.length; i < ii; i++) {\n        for (j = 0, jj = standardCalculatedPeriods[i].multipliers.length; j < jj; j++) {\n          key = standardCalculatedPeriods[i].multipliers[j] +\n            standardCalculatedPeriods[i].name;\n          calculatedObj[key] && calculatedObj[key].btn && calculatedObj[key].btn.show();\n        }\n      }\n      self.standardCalculatedPeriods = standardCalculatedPeriods;\n      self.toolbar && self.toolbar.redraw();\n      if (self.state) {\n        self.buttonGroup.setState && self.buttonGroup.setState(self.state);\n      } else {\n        self.buttonGroup.setState && self.buttonGroup.setState(null);\n      }\n    }\n\n    // ******** React on active property change ****\n\n    highlightActiveRange () {\n      // first check w.r.t contextual btns then others\n      var self = this,\n        clickedId = self.clickedId,\n        activeBtn,\n        contextualObj = self.btns.contextualObj,\n        calculatedObj = self.btns.calculatedObj;\n\n      // if the heighliter is not createcd create it\n      // if (!selectLine) {\n      //   selectLine = self.saveSelectLine || (self.saveSelectLine = self.graphics.paper.path({\n      //     'stroke': '#c95a5a',\n      //     'stroke-width': '2px'\n      //   }).toFront());\n      // }\n      activeBtn = contextualObj[clickedId] || calculatedObj[clickedId] || self.btns[clickedId];\n      if (activeBtn && activeBtn.btn) {\n        self.buttonGroup.setState(activeBtn.btn);\n        self.state = activeBtn.btn;\n      }\n      // if (activeBtn) {\n      //   boundElement = activeBtn.btn.svgElems.node;\n      //   bBox = boundElement.getBBox();\n      //   x1 = bBox.x;\n      //   x2 = x1 + bBox.width;\n      //   y2 = bBox.y + bBox.height;\n      //   selectLine.show().attr({\n      //     path: ['M', x1 + 1, y2 - 1.2, 'L', x2, y2 - 1.2]\n      //   });\n      // } else {\n      //   selectLine.hide();\n      // }\n    }\n\n    // --test case made--\n    onActiveRangeChange () {\n      var self = this,\n        x,\n        found,\n        categoryClicked = self.categoryClicked,\n        clickedId = self.clickedId,\n        startDataset = self.startDataset,\n        endDataset = self.endDataset,\n        startActiveWindow = self.startActiveWindow,\n        endActiveWindow = self.endActiveWindow,\n        contextualObj = self.btns.contextualObj,\n        calculatedObj = self.btns.calculatedObj,\n        lastClickedBtnObj;\n\n      if (categoryClicked === 'ALL') {\n        if (!(startDataset === startActiveWindow && endDataset === endActiveWindow)) {\n          delete self.clickedId;\n          delete self.categoryClicked;\n        }\n      } else if (categoryClicked === 'contextual') {\n        lastClickedBtnObj = contextualObj[clickedId];\n        if (lastClickedBtnObj && !(startActiveWindow === lastClickedBtnObj.contextStart &&\n          endActiveWindow === lastClickedBtnObj.contextEnd)) {\n          delete self.clickedId;\n          delete self.categoryClicked;\n        }\n      } else if (categoryClicked === 'calculated') {\n        lastClickedBtnObj = calculatedObj[clickedId];\n        if (lastClickedBtnObj && !((endActiveWindow - startActiveWindow) === lastClickedBtnObj.interval)) {\n          delete self.clickedId;\n          delete self.categoryClicked;\n        }\n      } else { // nothing is selected\n        if (startDataset === startActiveWindow && endDataset === endActiveWindow) {\n          self.clickedId = 'ALL';\n          self.categoryClicked = 'ALL';\n        } else {\n          for (x in contextualObj) {\n            lastClickedBtnObj = contextualObj[x];\n            if (startActiveWindow === lastClickedBtnObj.contextStart &&\n              endActiveWindow === lastClickedBtnObj.contextEnd) {\n              self.clickedId = x;\n              self.categoryClicked = 'contextual';\n              found = true;\n            }\n          }\n          if (!found) {\n            for (x in calculatedObj) {\n              lastClickedBtnObj = calculatedObj[x];\n              if ((endActiveWindow - startActiveWindow) === lastClickedBtnObj.interval) {\n                self.clickedId = x;\n                self.categoryClicked = 'calculated';\n              }\n            }\n          }\n          if (!found) {\n            delete self.state;\n          }\n        }\n      }\n      if (self.toolbarDrawn) {\n        self.showApplicableCalculatedButtons();\n        self.highlightActiveRange();\n      }\n    }\n\n    // *********** Draws the btns initialy ***** //\n\n    // --test case made--\n    // adds multipliers to the timerules object\n    processMultipliers (timeArr, customMultipliers) {\n      for (let i = 0, ii = timeArr.length; i < ii; i++) {\n        let len = timeArr[i].possibleFactors.length,\n          timeName = timeArr[i] && timeArr[i].name,\n          timeObj = timeArr && timeArr[i];\n        timeObj.multipliers = [];\n        if (customMultipliers === undefined) {\n          customMultipliers = {};\n        }\n        if (customMultipliers[timeName]) {\n          timeObj.multipliers = customMultipliers[timeName];\n        } else if (len === 1) {\n          timeObj.multipliers.push(timeObj.possibleFactors[0]);\n        } else if (len === 2) {\n          timeObj.multipliers.push(timeObj.possibleFactors[0]);\n          timeObj.multipliers.push(timeObj.possibleFactors[len - 1]);\n        } else {\n          timeObj.multipliers.push(timeObj.possibleFactors[0]);\n          timeObj.multipliers.push(Math.floor(timeObj.possibleFactors[len - 1] / 2));\n          timeObj.multipliers.push(timeObj.possibleFactors[len - 1]);\n        }\n      }\n      return timeArr;\n    }\n\n    createCalculatedButtons (buttonGroup) {\n      var self = this,\n        calculatedObj = self.btns.calculatedObj,\n        btnObj,\n        anchorPositions = self.anchorPositions,\n        minimumBucket = self.minimumBucket,\n        maximumBucket = self.maximumBucket,\n        model = self.globalReactiveModel.model,\n        btnList = {};\n\n      for (let i = self.timePeriods.length - 1; i >= 0; i--) {\n        for (let j = self.timePeriods[i].multipliers.length - 1; j >= 0; j--) {\n          let keyAbb = self.timePeriods[i].multipliers[j] + self.timePeriods[i].abbreviation.single,\n            keyName = self.timePeriods[i].multipliers[j] + self.timePeriods[i].name;\n          let interval = (self.timePeriods[i].multipliers[j] * self.timePeriods[i].interval);\n          if (interval > minimumBucket && interval < maximumBucket) {\n            btnObj = calculatedObj[keyName] = {\n              interval: interval,\n              fn: function () {\n                // self.toolbar && self.toolbar.redraw();\n                // buttonGroup.setState(this);\n                // self.state = this;\n                self.clickedId = keyName;\n                self.categoryClicked = 'calculated';\n                self.highlightActiveRange();\n                if (anchorPositions === 'right') {\n                  if (model['x-axis-absolute-range-start'] > self.endActiveWindow - interval) {\n                    self.globalReactiveModel\n                      .lock()\n                      .prop('x-axis-visible-range-end', model['x-axis-absolute-range-start'] + interval)\n                      .prop('x-axis-visible-range-start', self.startDataset)\n                      .unlock();\n                  } else {\n                    model['x-axis-visible-range-start'] = self.endActiveWindow - interval;\n                  }\n                } else {\n                  if (model['x-axis-absolute-range-end'] < self.startActiveWindow + interval) {\n                    self.globalReactiveModel\n                      .lock()\n                      .prop('x-axis-visible-range-end', self.endDataset)\n                      .prop('x-axis-visible-range-start', model['x-axis-absolute-range-end'] - interval)\n                      .unlock();\n                  } else {\n                    model['x-axis-visible-range-end'] = self.startActiveWindow + interval;\n                  }\n                }\n              },\n              shortKey: keyAbb\n            };\n\n            btnList[keyName] = {\n              text: keyAbb,\n              config: {\n                toolText: keyName,\n                height: 22,\n                radius: 1,\n                margin: {\n                  left: -4.5\n                }\n                // className: inputBtnStyles.className,\n                // states: {\n                //   selected: inputBtnStyles.states.selected.className,\n                //   errored: inputBtnStyles.states.errored.className\n                // }\n              },\n              group: buttonGroup,\n              eventListeners: {\n                'click': btnObj.fn\n              }\n            };\n            self.btns.calculatedObj[keyName] = btnObj;\n          }\n        }\n      }\n      self.createD3Buttons(btnList, 'calculatedObj');\n    }\n\n    // --test case made--\n    generateCtxBtnList () {\n      // generating an array with applicable TD buttons\n      var self = this,\n        buttons = self.standardContexualPeriods,\n        i = 0,\n        ii = 0,\n        endStamp = self.globalReactiveModel.model['x-axis-absolute-range-end'],\n        dateStart = endStamp - 2,\n        dateEnd = endStamp,\n        relativeTDButton = {},\n        tdButtons = self.tdButtons,\n        minimumBucket = self.minimumBucket || 1,\n        startActiveWindow = self.startActiveWindow,\n        endActiveWindow = self.endActiveWindow;\n\n      for (ii = tdButtons.length; i < ii; i++) {\n        dateStart = new Date(endStamp);\n        if (tdButtons[i].name === 'YTD') {\n          dateStart.setMonth(0);\n          dateStart.setDate(1);\n          dateStart.setHours(0);\n          dateStart.setMinutes(0);\n          dateStart.setSeconds(0);\n        } else if (tdButtons[i].name === 'MTD') {\n          dateStart.setDate(1);\n          dateStart.setHours(0);\n          dateStart.setMinutes(0);\n          dateStart.setSeconds(0);\n        } else if (tdButtons[i].name === 'QTD') {\n          dateStart.setMonth(11 - (dateStart.getMonth() % 4));\n          dateStart.setDate(0);\n          dateStart.setHours(0);\n          dateStart.setMinutes(0);\n          dateStart.setSeconds(0);\n        } else if (tdButtons[i].name === 'WTD') {\n          dateStart.setDate(dateStart.getDate() - dateStart.getDay());\n          dateStart.setHours(0);\n          dateStart.setMinutes(0);\n          dateStart.setSeconds(0);\n        } else if (tdButtons[i].name === 'Y') {\n          dateStart.setHours(0);\n          dateStart.setMinutes(0);\n          dateStart.setSeconds(0);\n          dateStart -= 86400000;\n        } else if (tdButtons[i].name === 'T') {\n          dateStart.setHours(0);\n          dateStart.setMinutes(0);\n          dateStart.setSeconds(0);\n          if (endStamp === +dateStart) {\n            dateStart = +dateStart - 86400000;\n          }\n        }\n\n        if (dateEnd < dateStart && (dateEnd - dateStart) < minimumBucket) {\n          continue;\n        } else {\n          tdButtons[i].dateStart = dateStart.valueOf();\n          tdButtons[i].dateEnd = dateEnd.valueOf();\n          buttons.push(tdButtons[i]);\n        }\n      }\n      relativeTDButton.milliseconds = Infinity;\n      for (i = 0, ii = tdButtons.length; i < ii; i++) {\n        if (Math.abs(tdButtons[i].milliseconds - (endActiveWindow - startActiveWindow)) < relativeTDButton.milliseconds) {\n          relativeTDButton.milliseconds = tdButtons[i].milliseconds;\n          relativeTDButton.name = tdButtons[i].abbreviation;\n        }\n      }\n    }\n\n    createContextualButtons (buttonGroup) {\n      var self = this,\n        contextualObj = self.btns.contextualObj,\n        btnObj,\n        keyName,\n        margin = 0,\n        contextualList = {};\n      self.generateCtxBtnList();\n      for (let i = 0, ii = this.standardContexualPeriods.length; i < ii; i++) {\n        if (!((self.standardContexualPeriods[i].dateEnd - self.standardContexualPeriods[i].dateStart >= self.minimumBucket) &&\n          (self.standardContexualPeriods[i].dateStart > self.startDataset))) {\n          continue;\n        }\n        keyName = self.standardContexualPeriods[i].abbreviation;\n        btnObj = contextualObj[keyName] = {\n          contextStart: self.standardContexualPeriods[i].dateStart,\n          contextEnd: self.standardContexualPeriods[i].dateEnd,\n          fn: function () {\n            // self.state = this;\n            self.categoryClicked = 'contextual';\n            self.clickedId = self.standardContexualPeriods[i].abbreviation;\n            self.highlightActiveRange();\n            self.globalReactiveModel\n              .lock()\n              .prop('x-axis-visible-range-end', self.standardContexualPeriods[i].dateEnd)\n              .prop('x-axis-visible-range-start', self.standardContexualPeriods[i].dateStart)\n              .unlock();\n          }\n        };\n\n        contextualList[self.standardContexualPeriods[i].abbreviation] = {\n          text: self.standardContexualPeriods[i].abbreviation,\n          config: {\n            toolText: keyName,\n            height: 22,\n            radius: 1,\n            margin: {\n              left: margin\n            }\n          },\n          group: buttonGroup,\n          eventListeners: {\n            'click': btnObj.fn\n          }\n        };\n\n        margin = -5;\n\n        self.btns.contextualObj[self.standardContexualPeriods[i].abbreviation] = btnObj;\n      }\n      self.createD3Buttons(contextualList, 'contextualObj');\n    }\n\n    addCssRules (classNames, styles) {\n      var key,\n        className,\n        paper = this.graphics.paper;\n      for (key in classNames) {\n        className = classNames[key];\n        switch (key) {\n          case 'container':\n            styles.container && paper.cssAddRule('.' + className, styles.container.style);\n            break;\n          case 'text':\n            styles.text && paper.cssAddRule('.' + className, styles.text.style);\n        }\n      }\n    }\n\n    createD3Buttons (store, obj) {\n      var key,\n        inputButton,\n        text,\n        config,\n        states,\n        state,\n        btn,\n        styles = this.extData.button,\n        paper = this.graphics.paper,\n        d3 = paper.getInstances().d3,\n        self = this;\n\n      for (key in store) {\n        inputButton = store[key];\n        text = inputButton.text;\n        config = inputButton.config;\n        // debugger\n        if (obj) {\n          if (!self.btns[obj][key]) {\n            self.btns[obj][key] = {};\n          }\n          btn = self.btns[obj][key].btn = d3.button(text).setConfig(config);\n        } else {\n          if (!self.btns[key]) {\n            self.btns[key] = {};\n          }\n          btn = self.btns[key].btn = d3.button(text).setConfig(config);\n        }\n        btn.namespace('fusioncharts');\n        btn.appendSelector('standarperiodselector');\n        self.addCssRules(btn.getIndividualClassNames(btn.getClassName()), styles);\n        states = styles.states;\n        for (state in states) {\n          self.addCssRules(btn.getIndividualClassNames(btn.config.states[state]), styles.states[state]);\n        }\n\n        inputButton.eventListeners && btn.attachEventHandlers({\n          click: inputButton.eventListeners.click.bind(btn)\n        });\n        inputButton.group.addSymbol(btn);\n      }\n    };\n\n    createD3Labels (store) {\n      var key,\n        label,\n        text,\n        config,\n        styles = this.extData.label,\n        self = this,\n        dependencies = {\n          paper: self.graphics.paper,\n          chart: self.chart,\n          smartLabel: self.smartLabel,\n          chartContainer: self.graphics.container\n        };\n\n      for (key in store) {\n        label = store[key];\n        text = label.text;\n        config = label.config;\n        self[key] = new self.toolbox.Label(text, dependencies, config);\n        // self[key].namespace('fusioncharts');\n        // self[key].appendSelector('daterange');\n        self.addCssRules(self[key].getIndividualClassNames(self[key].getClassName()), styles);\n        label.group.addSymbol(self[key]);\n      }\n    };\n\n    // creates toolbar\n    createToolbar () {\n      var self = this,\n        buttonGroup,\n        toolbar,\n        allButton,\n        label,\n        dummyList,\n        btnList,\n        group,\n        dummyButtonGroup,\n        dependencies = {\n          paper: self.graphics.paper,\n          chart: self.chart,\n          smartLabel: self.smartLabel,\n          chartContainer: self.graphics.container\n        };\n\n      // initiating the toolbar\n      toolbar = new self.HorizontalToolbar(dependencies);\n      toolbar.setConfig({\n        fill: '#fff',\n        borderThickness: 0\n      });\n\n      // making group for the extension label\n      group = new self.toolbox.ComponentGroup(dependencies);\n\n      // making buttonGroup for the buttons\n      buttonGroup = new self.toolbox.UniSelectComponentGroup(dependencies);\n\n      buttonGroup.defineStateIndicator(function (symbol) {\n        var bBox = symbol.getBBox(),\n          x1 = bBox.x,\n          x2 = x1 + bBox.width,\n          y2 = bBox.y + bBox.height;\n        // selectLine.show().attr({\n        //   path: ['M', x1 + 1, y2 - 1.2, 'L', x2, y2 - 1.2]\n        // });\n        return {\n          type: 'path',\n          attrs: {\n            d: ['M', x1 + 1, y2 - 1.2, 'L', x2, y2 - 1.2].join(' '),\n            'stroke-width': 2,\n            stroke: '#c95a5a'\n          }\n        };\n      });\n\n      // making buttonGroup for the buttons\n      dummyButtonGroup = new self.toolbox.ComponentGroup(dependencies);\n\n      // dummyButtonGroup.setConfig({\n      //   fill: '#fff',\n      //   borderThickness: 0\n      // });\n\n      buttonGroup.setConfig({\n        fill: '#fff',\n        borderThickness: 0\n      });\n      group.setConfig({\n        fill: '#fff',\n        borderThickness: 0\n      });\n\n      // extension label\n      label = {\n        'ZOOM': {\n          text: 'Zoom:',\n          config: {\n            height: 22,\n            margin: {\n              right: -12\n            }\n          },\n          group: group\n        }\n      };\n\n      self.createD3Labels(label);\n\n      // 'ALL' button created\n      allButton = self.allButtonShow && {fn: function () {\n        // buttonGroup.setState(this);\n        self.clickedId = 'ALL';\n        self.state = this;\n        self.categoryClicked = 'ALL';\n        self.highlightActiveRange();\n        self.globalReactiveModel\n          .lock()\n          .prop('x-axis-visible-range-end', self.endDataset)\n          .prop('x-axis-visible-range-start', self.startDataset)\n          .unlock();\n      }};\n\n      btnList = {\n        'ALL': {\n          text: 'ALL',\n          config: {\n            height: 22,\n            radius: 1,\n            toolText: 'ALL',\n            margin: {\n              right: 10\n            }\n          },\n          group: buttonGroup,\n          eventListeners: {\n            'click': allButton.fn\n          }\n        }\n      };\n\n      dummyList = {\n        'dummy': {\n          text: '___',\n          config: {\n            height: 22,\n            radius: 1\n            // className: inputBtnStyles.className,\n            // states: {\n            //   selected: inputBtnStyles.states.selected.className,\n            //   errored: inputBtnStyles.states.errored.className\n            // }\n          },\n          group: dummyButtonGroup\n        }\n      };\n\n      if (allButton) {\n        self.btns['ALL'] = allButton;\n        self.createD3Buttons(btnList);\n      }\n\n      // adding dummyButton\n      for (let i = 0; i < 6; i++) {\n        self.btns['dummy'] = {};\n        self.createD3Buttons(dummyList, 'dummy');\n      }\n\n      // adding group and button group to toolbar\n      toolbar.addComponent(group);\n      toolbar.addComponent(buttonGroup);\n      toolbar.addComponent(dummyButtonGroup);\n      self.toolbar = toolbar;\n      self.dummyButtonGroup = dummyButtonGroup;\n      self.buttonGroup = buttonGroup;\n      return toolbar;\n    };\n\n    appendButtons () {\n      var self = this,\n        buttonGroup = self.buttonGroup;\n      if (!Object.keys(self.btns.calculatedObj).length) {\n        // create all calculated button\n        self.calculatedButtonShow && self.createCalculatedButtons(buttonGroup);\n      }\n      if (!Object.keys(self.btns.contextualObj).length) {\n        // create all contextual button\n        self.contextualButtonShow && self.createContextualButtons(buttonGroup);\n      }\n    }\n\n    // *********** Extension interface methods *********//\n\n    init (require) {\n      var instance = this;\n      require([\n        'graphics',\n        'chart',\n        'canvasConfig',\n        'MarkerManager',\n        'reactiveModel',\n        'globalReactiveModel',\n        'spaceManagerInstance',\n        'smartLabel',\n        'extData',\n        'chartInstance',\n        'customExtremes',\n        function (\n              graphics,\n              chart,\n              canvasConfig,\n              markerManager,\n              reactiveModel,\n              globalReactiveModel,\n              spaceManagerInstance,\n              smartLabel,\n              extData,\n              chartInstance,\n              customExtremes) {\n          instance.graphics = graphics;\n          instance.chart = chart;\n          instance.markerManager = markerManager;\n          instance.canvasConfig = canvasConfig;\n          instance.reactiveModel = reactiveModel;\n          instance.globalReactiveModel = globalReactiveModel;\n          instance.spaceManagerInstance = spaceManagerInstance;\n          instance.smartLabel = smartLabel;\n          instance.extDataUser = extData;\n          instance.chartInstance = chartInstance;\n          instance.customExtremes = customExtremes;\n        }\n      ]);\n\n      instance.extData = {\n        'disabled': false,\n        'default-select': 'ALL',\n        'all-button': true,\n        'contextual-button': true,\n        'calculated-button': true,\n        'posWrtCanvas': 'top',\n        'anchor-align': 'right',\n        'layout': 'inline',\n        'alignment': 'left',\n        'orientation': 'horizontal',\n        'customMultipliers': {\n          'millisecond': [1, 500],\n          'second': [1, 5, 15, 30],\n          'minute': [1, 5, 15, 30],\n          'hour': [1, 3, 6, 12],\n          'day': [1, 7, 15],\n          'month': [1, 3, 6],\n          'year': [1, 3, 5]\n        },\n\n        button: {\n          height: 22,\n          radius: 1,\n          className: 'standard-period-selector',\n          container: {\n            style: {\n              fill: '#FFFFFF',\n              'stroke-width': '1px',\n              stroke: '#CED5D4',\n              labelFill: '#4b4b4b',\n              strokeWidth: '1px'\n              // 'input-shadow-fill': '#000000',\n              // 'input-shadow-opacity': 0.35,\n            }\n          },\n          text: {\n            style: {\n              'fontFamily': '\"Lucida Grande\", sans-serif',\n              'font-size': '13px',\n              'fill': '#4b4b4b',\n              'line-height': '1px',\n              'letter-spacing': '-0.04em'\n            }\n          },\n          states: {\n            hover: {\n              className: 'standard-period-selector-state-hover',\n              container: {\n                style: {\n                  cursor: 'pointer',\n                  fill: '#f7f7f7'\n                }\n              }\n            }\n          }\n        },\n        label: {\n          height: 22,\n          className: 'standard-period-selector-label',\n          text: {\n            style: {\n              'font-weight': 'bold',\n              'font-family': '\"Lucida Grande\", sans-serif',\n              'font-size': '13px',\n              'fill': '#4b4b4b'\n            }\n          }\n        }\n      };\n      Object.assign(instance.extData, instance.extDataUser);\n      instance.endActiveWindow = instance.globalReactiveModel.model['x-axis-visible-range-end'];\n      instance.startActiveWindow = instance.globalReactiveModel.model['x-axis-visible-range-start'];\n      instance.startDataset = instance.globalReactiveModel.model['x-axis-absolute-range-start'];\n      instance.endDataset = instance.globalReactiveModel.model['x-axis-absolute-range-end'];\n\n      instance.maximumBucket = instance.endDataset - instance.startDataset;\n\n      instance.timeRules = instance.chartInstance.apiInstance.getComponentStore();\n      instance.timeRules = instance.timeRules.getCanvasByIndex(0).composition.impl;\n      instance.timeRules = instance.timeRules.getDataAggregator();\n      instance.timeRules = instance.timeRules.getAggregationTimeRules();\n\n      instance.timePeriods = instance.processMultipliers(instance.timeRules, instance.extData.customMultipliers);\n\n      instance.allButtonShow = instance.extData['all-button'];\n      instance.calculatedButtonShow = instance.extData['calculated-button'];\n      instance.contextualButtonShow = instance.extData['contextual-button'];\n      instance.anchorPositions = instance.extData['anchor-align'];\n      instance.customMultipliers = instance.extData.customMultipliers;\n      instance.keySelect = instance.extData['default-select'];\n\n      instance.measurement = {};\n      instance.flag = true;\n      instance.toolbars = [];\n      instance.toolbars.push(instance.createToolbar());\n\n      instance.globalReactiveModel.onPropsChange(['x-axis-visible-range-start', 'x-axis-visible-range-end'],\n        instance.propsChangeListener);\n      instance.globalReactiveModel.onPropChange('x-axis-absolute-range-end', function (absEnd) {\n        if (instance.categoryClicked === 'contextual') {\n          instance.globalReactiveModel.model['x-axis-visible-range-end'] =\n            instance.globalReactiveModel.model['x-axis-absolute-range-end'];\n        }\n      });\n      return instance;\n    };\n\n    getLogicalSpace (availableWidth = this._pWidth, availableHeight = this._pHeight) {\n      var logicalSpace,\n        width = 0,\n        height = 0,\n        i,\n        ii,\n        self = this;\n\n      for (i = 0, ii = self.toolbars.length; i < ii; i++) {\n        logicalSpace = self.toolbars[i].getLogicalSpace(availableWidth, availableHeight);\n        width = Math.max(logicalSpace.width, width);\n        height += logicalSpace.height;\n        self.toolbars[i].width = logicalSpace.width;\n        self.toolbars[i].height = logicalSpace.height;\n      }\n      height += self.padding;\n      return {\n        width: width,\n        height: height\n      };\n    };\n\n    getDefaultGroup () {\n      return this.parentGroup;\n    }\n\n    placeInCanvas () {\n      var self = this;\n      self.padding = 5;\n      self.spaceManagerInstance.add([{\n        name: function () {\n          return 'standard-period-selector-ext';\n        },\n        ref: function (obj) {\n          return obj['0'];\n        },\n        self: function () {\n          return self;\n        },\n        priority: function () {\n          return 2;\n        },\n        layout: function (obj) {\n          return obj[self.extData.layout] || 'inline';\n        },\n        orientation: [{\n          type: function (obj) {\n            return obj[self.extData.orientation] || 'horizontal';\n          },\n          position: [{\n            type: function (obj) {\n              return obj[self.extData.posWrtCanvas] || 'top';\n            },\n            alignment: [{\n              type: function (obj) {\n                return obj[self.extData.alignment] || 'left';\n              },\n              dimensions: [function () {\n                var parent = this.getParentComponentGroup();\n                self._ref = this;\n                return self.getLogicalSpace((self._pWidth = parent.getWidth()), (self._pHeight = parent.getHeight()));\n              }]\n            }]\n          }]\n        }]\n      }]);\n    };\n\n    setDrawingConfiguration (x, y, width, height, group) {\n      var mes = this.measurement;\n      mes.x = x;\n      mes.y = y;\n      mes.width = width;\n      mes.height = height;\n\n      this.parentGroup = group;\n\n      return this;\n    };\n\n    // draws extension in the canvas\n    draw (x, y, width, height, group) {\n      var self = this,\n        measurement = self.measurement,\n        toolbars = self.toolbars,\n        ln,\n        i,\n        toolbar,\n        contextualObj = self.btns.contextualObj,\n        calculatedObj = self.btns.calculatedObj,\n        clickedId = self.clickedId,\n        activeBtn,\n        model = self.globalReactiveModel.model,\n        minimumBucket = self.minimumBucket,\n        buttonGroup = self.buttonGroup,\n        notFound,\n        key;\n\n      minimumBucket = model['minimum-consecutive-datestamp-diff'] * model['x-axis-maximum-allowed-ticks'];\n      self.minimumBucket = minimumBucket;\n\n      self.dummyButtonGroup.dispose();\n      toolbars[0].removeComponent(self.dummyButtonGroup);\n      // // create all calculated button\n      // self.calculatedButtonShow && self.createCalculatedButtons(buttonGroup);\n\n      // // create all contextual button\n      // self.contextualButtonShow && self.createContextualButtons(buttonGroup);\n      self.appendButtons();\n      buttonGroup.getLogicalSpace();\n      if (!Object.keys(self.customExtremes).length && self.keySelect) {\n        if (self.keySelect === 'ALL') {\n          self.clickedId = 'ALL';\n          self.state = self.btns['ALL'].btn;\n        } else if (contextualObj[self.keySelect]) {\n          self.clickedId = self.keySelect;\n        } else {\n          notFound = true;\n          for (key in calculatedObj) {\n            if (notFound && calculatedObj[key].shortKey === self.keySelect) {\n              self.clickedId = key;\n              notFound = false;\n            }\n          }\n        }\n        delete self.keySelect;\n        clickedId = self.clickedId;\n      }\n\n      x = x === undefined ? measurement.x : x;\n      y = y === undefined ? measurement.y : y;\n      width = width === undefined ? measurement.width : width;\n      height = height === undefined ? measurement.height : height;\n      group = group === undefined ? this.parentGroup : group;\n      if (width && height) {\n        for (i = 0, ln = toolbars.length; i < ln; i++) {\n          toolbar = toolbars[i];\n          toolbar.draw(x, y, group);\n          self.toolbarDrawn = true;\n        }\n        if (clickedId) {\n          activeBtn = calculatedObj[clickedId] || contextualObj[clickedId] || self.btns[clickedId];\n          if (activeBtn) {\n            activeBtn.fn && activeBtn.fn();\n          } else {\n            self.onActiveRangeChange();\n          }\n        } else {\n          self.onActiveRangeChange();\n        }\n      }\n    };\n  }\n  return StandardPeriodSelector;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/standard-period-selector.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}